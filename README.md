# Physical_Design
## This is Keerthana B (MS2024010)
## Course - Physical Design of ASICs ( VLS508)
# LAB-1
## Objective
Compile and verify a basic C code using GCC and the RISC-V GNU compiler toolchain on Ubuntu, and compare the outputs.
## Materials and Tools
 ## Software Tools:
 GCC (GNU Compiler Collection)<br/>
 RISC-V GNU Compiler Toolchain<br/>
 Ubuntu OS<br/>
## Pre-Lab Preparation
Installed GCC and RISC-V GNU Compiler Toolchain on Ubuntu.<br/>
Prepared a simple C program for compilation.<br/>
## Procedure
## Task 1: Compile and Verify C Code using GCC
### 1. Code Snippet:
```c
include<stdio.h>
int main()
{ int i,sum=0,n=5;
for(i=1;i<=n;++i)
{sum+=i;}
printf("sum of numbers from 1 to %d is %d\n",n,sum);
return 0;
}
```
### 2. Compile the code using GCC:
```
gcc sum1ton.c
```
### 3. Run the compiled code:
```
./a.out
```
### 4. Output: For different values of n values which is 5, 10, 100 the following figure contains the output.
```
The sum from 1 to 5 is 15
```
![results](https://github.com/user-attachments/assets/68da1fe2-13a7-4770-a7ca-0db35fd1c7d3)
## Task 2: Compile and Verify C Code using RISC-V GNU Compiler Toolchain
### 1. Display and Compile the code using RISC-V GCC:
```
riscv64-unknown-elf-gcc -O1 -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```
![risc1](https://github.com/user-attachments/assets/1d2a7bce-3d6b-46ac-bf73-57ad7ba683a9)

### 2. Run the compiled code (using an emulator if necessary):
```
riscv64-unknown-elf-objdump -d sum1ton.o | less
```
![risc2](https://github.com/user-attachments/assets/6d815db7-44b3-4d33-bc72-0b96b62e4d85)

### 3. Output(i): Here the -O1 optimization is used so the number of instructions is 15.

![risc3](https://github.com/user-attachments/assets/3b42727f-5f97-4f1f-8d8a-281de6c5b8ab)

### 4. Output(ii): Here the -Ofast optimization is used so the number of instructions are reduced to 12.

![risc5](https://github.com/user-attachments/assets/de60fb49-dae5-49e7-b3e2-129bf0ac015e)

![risc6](https://github.com/user-attachments/assets/c2eca8d6-feda-485d-b8de-eb6d860efb6c)

By comparing both -O1 and -Ofast, -Ofast gives the better optimization results which as only 12 instructions withrespect to the 15 instructions in -O1.

# LAB 2
## TASK 1
### Debugging with Spike Simulator and running object file generated by RISC-V Compiler in Spike Simulator
 The following steps to be followed. <br/>
## Step 1
 Compile sum1ton.c (C source file) into sum1ton.o (Object file) for RISC-V with Ofast Optimization
 ```
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```
## Step 2
Get the object dump using the command mentioned below
```
riscv64-unknown-elf-objdump -d sum1ton.o | less
```
![Screenshot from 2024-08-12 14-47-23](https://github.com/user-attachments/assets/1e802cc2-b16e-4d59-8ee9-ddd8e030088d)

 we get the following output 
 The snapshot of the assembly level of the main section of the program is shown below for reference

 ![Screenshot from 2024-08-12 14-53-44](https://github.com/user-attachments/assets/0ae0fe24-5c59-49a4-b463-23a7abe51002)

 ## Step 3

 Again compile the c program using gcc compiler and spike simulator. we get the following output shown below
![Screenshot from 2024-08-12 15-06-07](https://github.com/user-attachments/assets/d51a2222-9c63-4887-b90d-078b9f68b8cf)

## Step 4
For debugging the code, we use debugger using spike
```
spike -d pk sum1ton.o
```
we want to run our program till 100b0
```
until pc 0 100b0
```
After running the program manually, we can see the "bbl loader", this ensures that assembly code has run till 100b0 address, in my case <br/> 
* First command is lui a2,0x1 which changes a2 register <br/>
After excution of first instruction manually with spike debugger the a2 register value changes from 0x0000000000000000 to 0x0000000000001000 <br/>

we check the content of the register using following command
```
reg 0 a2
```
we will manually execute the next instruction i.e, lui a0,0x21 and addi sp,sp,-16 . this instruction will decrements the stact pointer. Before the execution the stack pointer register holds the value 0x0000003ffffffb50 and updated to 0x0000003ffffffb40 
```
reg 0 sp
```
after this instruction the stack pointer value is decremented by 10 in hexadecimal which is equivalent to 16 in decimal
![Screenshot from 2024-08-12 15-16-15](https://github.com/user-attachments/assets/eb7daffd-3b2b-4ddf-a586-2ccf4b0982c9)

# LAB 3

## TASK 1 : 32-bit RISC-V Instruction Formats: Encoding, Simulation and Waveform analysis
### RISC-V Instruction formats and Hexadecimal Encoding of Specific Instructions
### Base Instruction Formats

RISC-V has six core instruction formats: R,I,S,B,U and J. These are all fixed32 bit length. Here is a brief description of each format:

There are four core instruction formats (R/I/S/U), and there are a further two variants of the instruction formats (B/J) based on the handling of immediates.
1. **R-Type (Register)**
   + Format: funct7[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0]
   + Used for register-register arithmetic, logical operations and load instructions.
   ![Screenshot 2024-07-24 191624](https://github.com/user-attachments/assets/41f5fc12-5e58-4e60-bebc-8b1cef556214)

2. **I-Type (Immediate)**
   + Format: imm[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0]
   + Used for immediate arithmetic, logical operations and load instructions.
   ![Screenshot 2024-07-24 191624](https://github.com/user-attachments/assets/41f5fc12-5e58-4e60-bebc-8b1cef556214)    

3. **S-Type (Store)**
   + Format: imm[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[11:7] | opcode[6:0]
   + Used for store instructions.
   ![Screenshot 2024-07-24 191625](https://github.com/user-attachments/assets/446beff5-399d-4426-b868-0d9c6d2ef271)

4. **U-Type (Upper Immediate)**
   + Format: imm[31:12] | rd[11:7] | opcode[6:0]
   + Used for instructions that operate with a 20-bit upper immediate , such as LUI (Load Upper Immediate).
   ![Screenshot 2024-07-24 191626](https://github.com/user-attachments/assets/60c0073d-2e33-4fbd-a54b-01a606aeb353)

5. **B-Type (Branch)**
   +  Format: imm[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[11:7] | opcode[6:0]
   + Used for conditional branch instructions.
   ![Screenshot 2024-07-24 191847](https://github.com/user-attachments/assets/33c0c62f-3fe2-48bd-a1f5-18db951807cf)

6. **J-Type (Jump)**
   + Format: imm[31:20] | imm[19:12] | rd[11:7] | opcode[6:0]
   + Used for jump instructions such as JAL (Jump and Link).
   ![Screenshot 2024-07-24 191848](https://github.com/user-attachments/assets/7b2e93a1-1fc8-447f-95ed-1d34b82e8625)


## Instruction Analysis


| S.No | Assembly Instruction | Instruction Format |         32-Bit Instruction Code         | Hexadecimal Representation |
|------|----------------------|--------------------|-----------------------------------------|----------------------------|
|  1.  | ADD r9,r10,r11       |         R          | 0000000_01011_01010_000_01000_0110011   |        0x00B50433          |
|  2.  | SUB r11,r9,r10       |         R          | 0100000_01010_01001_000_01011_0110011   |        0x40A485B3          |
|  3.  | AND r10,r9,r11       |         R          | 0000000_01011_01001_111_01010_0110011   |        0x00B4F533          |
|  4.  | OR r8,r10,r5         |         R          | 0000000_00101_01010_110_01000_0110011   |        0x00556433          |
|  5.  | XOR r8,r9,r4         |         R          | 0000000_00100_01001_100_01000_0110011   |        0x0044C433          |
|  6.  | SLT r0,r1,r4         |         R          | 0000000_00100_00001_010_00000_0110011   |        0x0040A033          |
|  7.  | ADDI r2,r2,5         |         I          | 000000000101_00010_000_00010_0010011    |        0x00510113          |
|  8.  | SW r2,r0,4           |         S          | 0000000_00010_00000_010_00100_0100011   |        0x00202223          |
|  9.  | SRL r6,r1,r1         |         R          | 0000000_00001_00001_101_00110_0110011   |        0x0010D333          |
|  10. | BNE r0,r0,20         |         B          | 0_000000_00000_00000_001_0101_0_1100011 |        0x00001563          |
|  11. | BEQ r0,r0,15         |         B          | 0_000000_00000_00000_000_0111_1_1100011 |        0x000007E3          |
|  12. | LW r3,r1,2           |         I          | 000011111101_00010_010_00011_0000011    |        0x0FD12183          |
|  13. | SLL r5,r1,r1         |         R          | 0000000_00001_00001_001_00101_0110011   |        0x001092B3          |


# TASK 2 : Simulation and Waveform Analysis
### Steps to perform functional simulation

1. Create two files in gedit as riscv.v and riscv_tb.v
2. Copy the code from the reference github repository and paste it in your verilog and testbench files.
3. To run and Simulate the verilog code in gtkwave, enter the following commands:

![Screenshot from 2024-08-12 21-38-20](https://github.com/user-attachments/assets/5c1fc39f-6eb2-4654-b3fa-2cf8710b8604)


**Following are the differences between standard RISCV ISA and Hardcoded ISA for the instruction set given in the reference repository:**

The standard RISC-V ISA for the given instructions can be generated in a manner similar to the approach we used in Task 1

Hard-coded Instructions : These are the custom instructions where the bit patterns are manually set by the designer rather than adhering to the standard RISC-V specification. And they are designed for a specific purpose or application. Hence the 32-bits instruction that we generated will not match with the hardcoded ISA.


|   **Instructions**   |   **Standard RISCV ISA**   |   **Hardcoded ISA**   |
|    ADD R6, R2, R1    |    32'h00110R333  |  32'h02208300  |
|   SUB R7, R1, R2     |    32'h402083b3   |  32'h02209380  |
|  AND R8, R1, R3  |  32'h0030f433  |  32'h0230a400  |  
  |  OR R9, R2, R5  |  32'h005164b3  |  32'h02513480  |  
  |  XOR R10, R1, R4  |  32'h0040c533  |  32'h0240c500  |  
  |  SLT R1, R2, R4  |  32'h0045a0b3  |  32'h02415580  |  
  |  ADDI R12, R4, 5  |  32'h004120b3  |  32'h00520600  |  
  |  BEQ R0, R0, 15  |  32'h00000f63  |  32'h00f00002  |  
  |  SW R3, R1, 2  |  32'h0030a123  |  32'h00209181  |  
  |  LW R13, R1, 2  |  32'h0020a683  |  32'h00208681  |  
  |  SRL R16, R14, R2  |  32'h0030a123  |  32'h00271803  |
  |  SLL R15, R1, R2  |  32'h002097b3  |  32'h00208783  |  






