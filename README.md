# Physical_Design
## This is Keerthana B (MS2024010)
## Course - Physical Design of ASICs ( VLS508)
# LAB-1
## Objective
Compile and verify a basic C code using GCC and the RISC-V GNU compiler toolchain on Ubuntu, and compare the outputs.
## Materials and Tools
 ## Software Tools:
 GCC (GNU Compiler Collection)<br/>
 RISC-V GNU Compiler Toolchain<br/>
 Ubuntu OS<br/>
## Pre-Lab Preparation
Installed GCC and RISC-V GNU Compiler Toolchain on Ubuntu.<br/>
Prepared a simple C program for compilation.<br/>
## Procedure
## Task 1: Compile and Verify C Code using GCC
### 1. Code Snippet:
```c
include<stdio.h>
int main()
{ int i,sum=0,n=5;
for(i=1;i<=n;++i)
{sum+=i;}
printf("sum of numbers from 1 to %d is %d\n",n,sum);
return 0;
}
```
### 2. Compile the code using GCC:
```
gcc sum1ton.c
```
### 3. Run the compiled code:
```
./a.out
```
### 4. Output: For different values of n values which is 5, 10, 100 the following figure contains the output.
```
The sum from 1 to 5 is 15
```
![results](https://github.com/user-attachments/assets/68da1fe2-13a7-4770-a7ca-0db35fd1c7d3)
## Task 2: Compile and Verify C Code using RISC-V GNU Compiler Toolchain
### 1. Display and Compile the code using RISC-V GCC:
```
riscv64-unknown-elf-gcc -O1 -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```
![risc1](https://github.com/user-attachments/assets/1d2a7bce-3d6b-46ac-bf73-57ad7ba683a9)

### 2. Run the compiled code (using an emulator if necessary):
```
riscv64-unknown-elf-objdump -d sum1ton.o | less
```
![risc2](https://github.com/user-attachments/assets/6d815db7-44b3-4d33-bc72-0b96b62e4d85)

### 3. Output(i): Here the -O1 optimization is used so the number of instructions is 15.

![risc3](https://github.com/user-attachments/assets/3b42727f-5f97-4f1f-8d8a-281de6c5b8ab)

### 4. Output(ii): Here the -Ofast optimization is used so the number of instructions are reduced to 12.

![risc5](https://github.com/user-attachments/assets/de60fb49-dae5-49e7-b3e2-129bf0ac015e)

![risc6](https://github.com/user-attachments/assets/c2eca8d6-feda-485d-b8de-eb6d860efb6c)

By comparing both -O1 and -Ofast, -Ofast gives the better optimization results which as only 12 instructions withrespect to the 15 instructions in -O1.

# LAB 2
## TASK 1
### Debugging with Spike Simulator and running object file generated by RISC-V Compiler in Spike Simulator
 The following steps to be followed. <br/>
## Step 1
 Compile sum1ton.c (C source file) into sum1ton.o (Object file) for RISC-V with Ofast Optimization
 ```
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
```
## Step 2
Get the object dump using the command mentioned below
```
riscv64-unknown-elf-objdump -d sum1ton.o | less
```
![Screenshot from 2024-08-12 14-47-23](https://github.com/user-attachments/assets/1e802cc2-b16e-4d59-8ee9-ddd8e030088d)

 we get the following output 
 The snapshot of the assembly level of the main section of the program is shown below for reference

 ![Screenshot from 2024-08-12 14-53-44](https://github.com/user-attachments/assets/0ae0fe24-5c59-49a4-b463-23a7abe51002)

 ## Step 3

 Again compile the c program using gcc compiler and spike simulator. we get the following output shown below
![Screenshot from 2024-08-12 15-06-07](https://github.com/user-attachments/assets/d51a2222-9c63-4887-b90d-078b9f68b8cf)

## Step 4
For debugging the code, we use debugger using spike
```
spike -d pk sum1ton.o
```
we want to run our program till 100b0
```
until pc 0 100b0
```
After running the program manually, we can see the "bbl loader", this ensures that assembly code has run till 100b0 address, in my case <br/> 
* First command is lui a2,0x1 which changes a2 register <br/>
After excution of first instruction manually with spike debugger the a2 register value changes from 0x0000000000000000 to 0x0000000000001000 <br/>

we check the content of the register using following command
```
reg 0 a2
```
we will manually execute the next instruction i.e, lui a0,0x21 and addi sp,sp,-16 . this instruction will decrements the stact pointer. Before the execution the stack pointer register holds the value 0x0000003ffffffb50 and updated to 0x0000003ffffffb40 
```
reg 0 sp
```
after this instruction the stack pointer value is decremented by 10 in hexadecimal which is equivalent to 16 in decimal
![Screenshot from 2024-08-12 15-16-15](https://github.com/user-attachments/assets/eb7daffd-3b2b-4ddf-a586-2ccf4b0982c9)

# LAB 3

## TASK 1 : 32-bit RISC-V Instruction Formats: Encoding, Simulation and Waveform analysis
### RISC-V Instruction formats and Hexadecimal Encoding of Specific Instructions
### Base Instruction Formats

RISC-V has six core instruction formats: R,I,S,B,U and J. These are all fixed32 bit length. Here is a brief description of each format:

There are four core instruction formats (R/I/S/U), and there are a further two variants of the instruction formats (B/J) based on the handling of immediates.
1. **R-Type (Register)**
   + Format: funct7[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0]
   + Used for register-register arithmetic, logical operations and load instructions.
   ![Screenshot 2024-07-24 191624](https://github.com/user-attachments/assets/41f5fc12-5e58-4e60-bebc-8b1cef556214)

2. **I-Type (Immediate)**
   + Format: imm[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0]
   + Used for immediate arithmetic, logical operations and load instructions.
   ![Screenshot 2024-07-24 191624](https://github.com/user-attachments/assets/41f5fc12-5e58-4e60-bebc-8b1cef556214)    

3. **S-Type (Store)**
   + Format: imm[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[11:7] | opcode[6:0]
   + Used for store instructions.
   ![Screenshot 2024-07-24 191625](https://github.com/user-attachments/assets/446beff5-399d-4426-b868-0d9c6d2ef271)

4. **U-Type (Upper Immediate)**
   + Format: imm[31:12] | rd[11:7] | opcode[6:0]
   + Used for instructions that operate with a 20-bit upper immediate , such as LUI (Load Upper Immediate).
   ![Screenshot 2024-07-24 191626](https://github.com/user-attachments/assets/60c0073d-2e33-4fbd-a54b-01a606aeb353)

5. **B-Type (Branch)**
   +  Format: imm[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[11:7] | opcode[6:0]
   + Used for conditional branch instructions.
   ![Screenshot 2024-07-24 191847](https://github.com/user-attachments/assets/33c0c62f-3fe2-48bd-a1f5-18db951807cf)

6. **J-Type (Jump)**
   + Format: imm[31:20] | imm[19:12] | rd[11:7] | opcode[6:0]
   + Used for jump instructions such as JAL (Jump and Link).
   ![Screenshot 2024-07-24 191848](https://github.com/user-attachments/assets/7b2e93a1-1fc8-447f-95ed-1d34b82e8625)


## Instruction Analysis


| S.No | Assembly Instruction | Instruction Format |         32-Bit Instruction Code         | Hexadecimal Representation |
|------|----------------------|--------------------|-----------------------------------------|----------------------------|
|  1.  | ADD r9,r10,r11       |         R          | 0000000_01011_01010_000_01000_0110011   |        0x00B50433          |
|  2.  | SUB r11,r9,r10       |         R          | 0100000_01010_01001_000_01011_0110011   |        0x40A485B3          |
|  3.  | AND r10,r9,r11       |         R          | 0000000_01011_01001_111_01010_0110011   |        0x00B4F533          |
|  4.  | OR r8,r10,r5         |         R          | 0000000_00101_01010_110_01000_0110011   |        0x00556433          |
|  5.  | XOR r8,r9,r4         |         R          | 0000000_00100_01001_100_01000_0110011   |        0x0044C433          |
|  6.  | SLT r0,r1,r4         |         R          | 0000000_00100_00001_010_00000_0110011   |        0x0040A033          |
|  7.  | ADDI r2,r2,5         |         I          | 000000000101_00010_000_00010_0010011    |        0x00510113          |
|  8.  | SW r2,r0,4           |         S          | 0000000_00010_00000_010_00100_0100011   |        0x00202223          |
|  9.  | SRL r6,r1,r1         |         R          | 0000000_00001_00001_101_00110_0110011   |        0x0010D333          |
|  10. | BNE r0,r0,20         |         B          | 0_000000_00000_00000_001_0101_0_1100011 |        0x00001563          |
|  11. | BEQ r0,r0,15         |         B          | 0_000000_00000_00000_000_0111_1_1100011 |        0x000007E3          |
|  12. | LW r3,r1,2           |         I          | 000011111101_00010_010_00011_0000011    |        0x0FD12183          |
|  13. | SLL r5,r1,r1         |         R          | 0000000_00001_00001_001_00101_0110011   |        0x001092B3          |


# TASK 2 : Simulation and Waveform Analysis
### Steps to perform functional simulation

1. Create two files in gedit as riscv.v and riscv_tb.v
2. Copy the code from the reference github repository and paste it in your verilog and testbench files.
3. To run and Simulate the verilog code in gtkwave, enter the following commands:

![Screenshot from 2024-08-12 21-38-20](https://github.com/user-attachments/assets/5c1fc39f-6eb2-4654-b3fa-2cf8710b8604)


**Following are the differences between standard RISCV ISA and Hardcoded ISA for the instruction set given in the reference repository:**

The standard RISC-V ISA for the given instructions can be generated in a manner similar to the approach we used in Task 1

Hard-coded Instructions : These are the custom instructions where the bit patterns are manually set by the designer rather than adhering to the standard RISC-V specification. And they are designed for a specific purpose or application. Hence the 32-bits instruction that we generated will not match with the hardcoded ISA.


|   **Instructions**   |   **Standard RISCV ISA**   |   **Hardcoded ISA**   |
|----------------------|----------------------------|-----------------------|
|  ADD R6, R2, R1      |    32'h00110R333           |  32'h02208300  |
|  SUB R7, R1, R2      |    32'h402083b3            |  32'h02209380  |
|  AND R8, R1, R3      |    32'h0030f433            |  32'h0230a400  |  
|  OR R9, R2, R5       |    32'h005164b3            |  32'h02513480  |  
|  XOR R10, R1, R4     |    32'h0040c533            |  32'h0240c500  |  
|  SLT R1, R2, R4      |    32'h0045a0b3            |  32'h02415580  |  
|  ADDI R12, R4, 5     |    32'h004120b3            |  32'h00520600  |  
|  BEQ R0, R0, 15      |    32'h00000f63            |  32'h00f00002  |  
|  SW R3, R1, 2        |    32'h0030a123            |  32'h00209181  |  
|  LW R13, R1, 2       |    32'h0020a683            |  32'h00208681  |  
|  SRL R16, R14, R2    |    32'h0030a123            |  32'h00271803  |
|  SLL R15, R1, R2     |    32'h002097b3            |  32'h00208783  |  


### Analysing the output of above given instructions:

```
ADD R6, R2, R1
```
![Screenshot from 2024-08-12 20-00-44](https://github.com/user-attachments/assets/0a2ee2d3-fa6c-489b-bdfe-4efd75d279a9)

```
SUB R7, R1, R2
```
![Screenshot from 2024-08-12 20-01-55](https://github.com/user-attachments/assets/86b18f92-0831-44ed-b046-c92041572610)

```
AND R8, R1, R3
```
![Screenshot from 2024-08-12 20-02-00](https://github.com/user-attachments/assets/5079a999-696b-49a9-a37c-4a67fe6b3a27)

```
OR R9, R2, R5
```
![Screenshot from 2024-08-12 20-02-04](https://github.com/user-attachments/assets/88513ceb-9461-4f10-a358-9d018ae84f86)

```
XOR R10, R1, R4
```
![Screenshot from 2024-08-12 20-02-08](https://github.com/user-attachments/assets/55ab8328-22ae-475d-b4ec-60c6126d1f2f)

```
SLT R1, R2, R4
```
![Screenshot from 2024-08-12 20-02-11](https://github.com/user-attachments/assets/d6002341-7158-45de-9cf4-859cb292b5e6)

```
ADDI R12,R4,5
```
![Screenshot from 2024-08-12 20-02-14](https://github.com/user-attachments/assets/89f81309-6dd0-49ba-8dab-bc392b606e00)

```
BEQ R0, R0, 15
```
![Screenshot from 2024-08-12 20-02-17](https://github.com/user-attachments/assets/bb3dfd2e-cea8-4746-93b3-761612e78916)

```
SW R3, R1, 2
```
![Screenshot from 2024-08-12 20-02-27](https://github.com/user-attachments/assets/c69ea663-cf5e-48ad-9581-8ebe270fc49d)

```
LW R13, R1, 2
```
![Screenshot from 2024-08-12 20-03-05](https://github.com/user-attachments/assets/4d5aec42-c22d-4a86-b4ef-1271b3613677)

```
SRL R16, R14, R2
```
![Screenshot from 2024-08-12 20-03-13](https://github.com/user-attachments/assets/2db2ec0e-701a-446a-a541-4e0b5bd6b385)

```
SLL R15, R1, R2
```
![Screenshot from 2024-08-12 20-03-19](https://github.com/user-attachments/assets/4fdf0d3c-50d6-4a0b-881a-ceec21e324f0)


# LAB 4: Selecting and Compiling a Application using GCC and RISC-V GCC
## Application Name: Temperature Converter
### Overview: It convertes the temperature from celcius to fahrenheit and from fahrenheit to celcius.
**Temperature Converter** is a C-based application which converts the temperature to different scales like from celcius to fahrenheit and also from fahrenheit to celcius. 

**Code**
```c

#include <stdio.h>

int main() {
    float celsius, fahrenheit;
    int choice;

    printf("Enter 1 to convert Celsius to Fahrenheit or 2 for Fahrenheit to Celsius: ");
    scanf("%d", &choice);

    if (choice == 1) {
        printf("Enter temperature in Celsius: ");
        scanf("%f", &celsius);
        fahrenheit = (celsius * 9/5) + 32;
        printf("Temperature in Fahrenheit: %.2f\n", fahrenheit);
    } else if (choice == 2) {
        printf("Enter temperature in Fahrenheit: ");
        scanf("%f", &fahrenheit);
        celsius = (fahrenheit - 32) * 5/9;
        printf("Temperature in Celsius: %.2f\n", celsius);
    } else {
        printf("Invalid choice\n");
    }

    return 0;
}

```
### Compiling the Application using GCC Compiler
![Screenshot 2024-08-14 213445](https://github.com/user-attachments/assets/e9bd8be3-b484-459e-97f2-f71d9b57854e)


# LAB 5

# Digital Logic with TL-Verilog and Makerchip

#### MAKERCHIP 
Makerchip is a free online environment by Redwood EDA for developing high-quality integrated circuits. The online platform can be used to code, compile, simulate and debug Verilog designs all in just one tool. Access and learn from [here](http://makerchip.com/)
   
#### TL VERILOG
Transaction Level Verilog or TL-Verilog is an extension to existing Verilog HDL and a huge step forward in coding HDL languages. TL-Verilog introduces simpler syntaxes and adds powerful constructs which makes Logic Design fun and easy. (Also can say its a Higher Abstraction to Sys V). Generally, high-speed designs are less than half the size in TL-Verilog versus SystemVerilog without any loss in detail! More about it [here](https://www.redwoodeda.com/tl-verilog)
  
 #### DIGITAL DESIGN
  
  Below are a set of images from Makerchip showcasing the TL-V code for Combinational and sequential logic and Simulation Output. Most of the basic circuits examples can be found in Makerchip Tutorials anexhaustive list to get anyone enough information to learn the platform and TL-Verilog.

### (i) Combinational Logic
  
1. Inverter
   
   ![Screenshot 2024-08-20 192005](https://github.com/user-attachments/assets/e5205387-c5fc-40ca-a105-54e11c1f7d0e)

3. AND Gate

   ![Screenshot 2024-08-20 192115](https://github.com/user-attachments/assets/e3f7c9a2-a90c-4b47-826c-ee9ce975f503)

3. OR Gate

   ![Screenshot 2024-08-20 192155](https://github.com/user-attachments/assets/dc9c469a-3e78-43b4-98c1-13d2b489e7a1)

4. XOR gate using vectors

   ![Screenshot 2024-08-20 192702](https://github.com/user-attachments/assets/2adf1511-63ce-4d98-96b5-a141d52b55f1)

### (ii) Sequential Logic

1. Sequential Calculator

  <img width="959" alt="sequential calculator" src="https://github.com/user-attachments/assets/a3541ba8-13e0-47e9-aed8-75d94a1fa769">

2. Fibonacci series

  ![Screenshot 2024-08-20 194104](https://github.com/user-attachments/assets/12515516-8be2-4ade-8975-a0cca7fdec19)

3. Free running Counter

   ![Screenshot 2024-08-20 194245](https://github.com/user-attachments/assets/fba5c820-366c-464c-9f92-1604e166e50f)

### (iii) Pipelining

1. Pythagoras Theorem

   <img width="959" alt="pythagoras" src="https://github.com/user-attachments/assets/81fb9339-5f5c-46de-b869-51204a2d4586">

2. Cycle calculator

   <img width="958" alt="cycle calculator" src="https://github.com/user-attachments/assets/e39b9b9b-0e95-4d53-93b0-8b86a1bab00d">

3. Cycle calculator with validity

   ![cycle calculator with validity](https://github.com/user-attachments/assets/f69ff9eb-aa1b-45e9-acb0-e04cdc2125f7)

4. 2-cycle calculator with validity and memory

   ![calculator with 2 cycle](https://github.com/user-attachments/assets/bbe6e0a4-1837-4465-87ef-5d6a4170f784)


# RISCV Core Implementation

#### the overall code is as shown
```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      
      
      @0
         $clk_keer = *clk;
         $reset = *reset;
         $pc[31:0] = >>1$reset ? 1'b0 : >>1$taken_branch ? >>1$br_tgt_pc : >>1$pc + 32'd4;
         
      @1 
         $imem_rd_en = !$reset;
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
         $inst[31:0] = $imem_rd_data[31:0]; 
         
         $is_i_instr = $inst[6:2] ==? 5'b0000x ||
                       $inst[6:2] ==? 5'b001x0 ||
                       $inst[6:2] ==? 5'b11001;
                       
         
         $is_u_instr = $inst[6:2] ==? 5'b0x101;
         
         $is_r_instr = $inst[6:2] ==? 5'b01011 ||
                       $inst[6:2] ==? 5'b011x0 ||
                       $inst[6:2] ==? 5'b10100;
         
         $is_b_instr = $inst[6:2] ==? 5'b11000;
         
         $is_j_instr = $inst[6:2] ==? 5'b11011;
         
         $is_s_instr = $inst[6:2] ==? 5'b0100x;
         
         
         $imm[31:0] = $is_i_instr ? {{21{$inst[31]}}, $inst[30:20]} :
                      $is_s_instr ? {{21{$inst[31]}}, $inst[30:25], $inst[11:8], $inst[7]} :
                      $is_b_instr ? {{20{$inst[31]}}, $inst[7], $inst[30:25], $inst[11:8], 1'b0} :
                      $is_u_instr ? {$inst[31], $inst[30:20], $inst[19:12], 12'b0} :
                      $is_j_instr ? {{12{$inst[31]}}, $inst[19:12], $inst[20], $inst[30:21], 1'b0} :
                                    32'b0;
         
         $rs1_use = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_use
            $rs1[4:0] = $inst[19:15];
         
         $rs2_use = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_use
            $rs2[4:0] = $inst[24:20];
            
         $funct3_use = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_use
            $funct3[2:0] = $inst[14:12];
            
         $funct7_use = $is_r_instr ;
         ?$funct7_use
            $funct7[6:0] = $inst[31:25];
            
         $rd_use = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_use
            $rd[4:0] = $inst[11:7];
         
         $opcode[6:0] = $inst;
         
         $dec_bits [10:0] = {$funct7[5], $funct3, $opcode};
         
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         
         //Register Read 
         $rf_rd_en1 = $rs1_use;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_use;
         $rf_rd_index2[4:0] = $rs2;
         
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;
         
       
         
         //ALU
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         32'bx ;
         
         //Register File Write 
         
         $rf_wr_en = $rd_use;
         $rf_wr_index[4:0] = $rd;
         $rf_wr_data[31:0] = $rd == 0 ? 0 : $result;
         
         //Branch Instructions
         
         $taken_branch = $is_beq ? ($src1_value == $src2_value):
                         $is_bne ? ($src1_value != $src2_value):
                         $is_blt ? (($src1_value < $src2_value)^($src1_value[31] != $src2_value[31])):
                         $is_bge ? (($src1_value >= $src2_value)^($src1_value[31] != $src2_value[31])):
                         $is_bltu ? ($src1_value < $src2_value):
                         $is_bgeu ? ($src1_value >= $src2_value):
                                    1'b0;
         `BOGUS_USE($taken_branch)
         $br_tgt_pc[31:0] = $pc + $imm;
         
         //Testbench
         *passed = |cpu/xreg[10]>>5$value == (1+2+3+4+5+6+7+8+9) ;
      // YOUR CODE HERE
      // ...

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)

   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule

```
![Screenshot 2024-08-21 212400](https://github.com/user-attachments/assets/99aaed75-fb8c-4457-a2dd-a08b563d2789)
![Screenshot 2024-08-21 212029](https://github.com/user-attachments/assets/e90d09d5-54ae-4adc-8934-98ff7aa8f3bd)

### Complete Pipelined RISCV core 

```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      
      
      @0
         $clk_keer = *clk;
         $reset = *reset;
         $pc[31:0] = >>1$reset ? 32'b0 :
                     >>3$valid_taken_branch ? >>3$br_tgt_pc :
                     >>3$valid_load ? >>3$inc_pc : 
                     (>>3$valid_jump && >>3$is_jal) ? >>3$br_tgt_pc :
                     (>>3$valid_jump && >>3$is_jalr) ? >>3$jalr_tgt_pc :
                     >>1$inc_pc;
      
      @1 
         $inc_pc = $pc + 32'd4;
         $imem_rd_en = !>>1$reset;
         $imem_rd_addr[M4_IMEM_INDEX_CNT-1:0] = $pc[M4_IMEM_INDEX_CNT+1:2];
      
      
      
      @3 
          //valid 
         $valid = !(>>1$valid_taken_branch || >>2$valid_taken_branch || >>1$valid_load || >>2$valid_load 
                    || >>1$valid_jump || >>2$valid_jump) ;
                    
         $valid_load = $valid && $is_load ;
         $valid_jump = $valid && $is_load;
      
      
         
      @1   
         $inst[31:0] = $imem_rd_data[31:0]; 
         
         // Assigning instruction type signal i.e. decoding instruction type
         $is_i_instr = $inst[6:2] ==? 5'b0000x ||
                       $inst[6:2] ==? 5'b001x0 ||
                       $inst[6:2] ==? 5'b11001;
                       
         
         $is_u_instr = $inst[6:2] ==? 5'b0x101;
         
         $is_r_instr = $inst[6:2] ==? 5'b01011 ||
                       $inst[6:2] ==? 5'b011x0 ||
                       $inst[6:2] ==? 5'b10100;
         
         $is_b_instr = $inst[6:2] ==? 5'b11000;
         
         $is_j_instr = $inst[6:2] ==? 5'b11011;
         
         $is_s_instr = $inst[6:2] ==? 5'b0100x;
         
         //Decoding Immediate 
         $imm[31:0] = $is_i_instr ? {{21{$inst[31]}}, $inst[30:20]} :
                      $is_s_instr ? {{21{$inst[31]}}, $inst[30:25], $inst[11:8], $inst[7]} :
                      $is_b_instr ? {{20{$inst[31]}}, $inst[7], $inst[30:25], $inst[11:8], 1'b0} :
                      $is_u_instr ? {$inst[31], $inst[30:20], $inst[19:12], 12'b0} :
                      $is_j_instr ? {{12{$inst[31]}}, $inst[19:12], $inst[20], $inst[30:21], 1'b0} :
                                    32'b0;
         $opcode[6:0] = $inst[6:0];
          
          
         $rs1_use = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_use
            $rs1[4:0] = $inst[19:15];
         
         $rs2_use = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_use
            $rs2[4:0] = $inst[24:20];
            
         $funct3_use = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_use
            $funct3[2:0] = $inst[14:12];
            
         $funct7_use = $is_r_instr ;
         ?$funct7_use
            $funct7[6:0] = $inst[31:25];
            
         $rd_use = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_use
            $rd[4:0] = $inst[11:7];
         
        
         
         $dec_bits[10:0] = {$funct7[5], $funct3, $opcode};
         
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         $is_load = $dec_bits ==? 11'bx_xxx_0000011;
         $is_sb = $dec_bits ==? 11'bx_000_0100011;
         $is_sh = $dec_bits ==? 11'bx_001_0100011;
         $is_sw = $dec_bits ==? 11'bx_010_0100011;
         $is_slti = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0010011;
         $is_xori = $dec_bits ==? 11'bx_100_0010011;
         $is_ori = $dec_bits ==? 11'bx_110_0010011;
         $is_andi = $dec_bits ==? 11'bx_111_0010011;
         $is_slli = $dec_bits ==? 11'b0_001_0010011;
         $is_srli = $dec_bits ==? 11'b0_101_0010011;
         $is_srai = $dec_bits ==? 11'b1_101_0010011;
         $is_sub = $dec_bits ==? 11'b1_000_0110011;
         $is_sll = $dec_bits ==? 11'b0_001_0110011;
         $is_slt = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu = $dec_bits ==? 11'b0_011_0110011;
         $is_xor = $dec_bits ==? 11'b0_100_0110011;
         $is_srl = $dec_bits ==? 11'b0_101_0110011;
         $is_sra = $dec_bits ==? 11'b1_101_0110011;
         $is_or = $dec_bits ==? 11'b0_110_0110011;
         $is_and = $dec_bits ==? 11'b0_111_0110011;
         $is_lui = $dec_bits ==? 11'bx_xxx_0110111;
         $is_auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $is_jal = $dec_bits ==? 11'bx_xxx_1101111;
         $is_jalr = $dec_bits ==? 11'bx_000_1100111;
         $is_jump = $is_jal || $is_jalr ;
         
         `BOGUS_USE($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu $is_addi $is_add) 
         
         
      @2
         //Register Read 
         $rf_rd_en1 = $rs1_use && >>2$result;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_use && >>2$result;
         $rf_rd_index2[4:0] = $rs2;
         
         //$src1_value[31:0] = $rf_rd_data1;
         //$src2_value[31:0] = $rf_rd_data2;
         
         //Branching Criteria for Program Counter 
         $br_tgt_pc[31:0] = $pc + $imm;
         
         
         
         //source to alu assigned with o/p of read register
         $src1_value[31:0] = 
              (>>1$rf_wr_index == $rf_rd_index1) && >>1$rf_wr_en ?
                 >>1$result :
                  $rf_rd_data1;
         $src2_value[31:0] = 
              (>>1$rf_wr_index == $rf_rd_index2) && >>1$rf_wr_en ?
                 >>1$result :
                   $rf_rd_data2;
      
         //Data Memory Read - Write
      @4
         $dmem_wr_en = $is_s_instr && $valid ;
         $dmem_addr[3:0] = $result[5:2] ;
         $dmem_wr_data[31:0] = $src2_value ;
         $dmem_rd_en = $is_load ;
         
      @4 
         //LOAD DATA
         $ld_data[31:0] = $dmem_rd_data ;
      
      @3
         
         $jalr_tgt_pc[31:0] = $src1_value + $imm ;  
         
         
      @3   
         //ALU
         
         $sltu_rslt[31:0] = $src1_value < $src2_value ;
         $sltiu_rslt[31:0]  = $src1_value < $imm ;
         
         
         $result[31:0] = $is_addi ? $src1_value + $imm :
              $is_add ? $src1_value + $src2_value :
              $is_andi ? $src1_value & $imm :
              $is_ori  ? $src1_value | $imm :
              $is_xori ? $src1_value ^ $imm :
              $is_slli ? $src1_value << $imm[5:0] :
              $is_srli ? $src1_value >> $imm[5:0] :
              $is_and ? $src1_value & $src2_value :
              $is_or ? $src1_value | $src2_value :
              $is_xor ? $src1_value ^ $src2_value :
              $is_sub ? $src1_value - $src2_value :
              $is_sll ? $src1_value << $src2_value[4:0] :
              $is_srl ? $src1_value >> $src2_value[4:0] :
              $is_sltu ? $src1_value < $src2_value :
              $is_sltiu ? $src1_value < $imm :
              $is_lui ? {$imm[31:12], 12'b0} :
              $is_auipc ? $pc + $imm : 
              $is_jal ? $pc + 32'd4 :
              $is_jalr ? $pc + 32'd4 :
              $is_srai ? {{32{$src1_value[31]}}, $src1_value} >> $imm[4:0] :
              $is_slt ? ($src1_value[31] == $src2_value[31]) ? $sltu_rslt : {31'b0, $src1_value[31]} :
              $is_slti ? ($src1_value[31] == $imm[31]) ? $sltiu_rslt : {31'b0, $src1_value[31]} :
              $is_sra ? {{32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0] :
              $is_load || $is_s_instr ? $src1_value + $imm :
              32'bx ;
      @3
         //Register File Write 
         
         $rf_wr_en = $rd_use && $rd != 5'b0 && $valid || >>2$valid_load;
         $rf_wr_index[4:0] = >>2$valid_load ? >>2$rd : $rd;
         $rf_wr_data[31:0] = >>2$valid_load ? >>2$ld_data :  $result;
         
         //Branch Instructions
         
         $taken_branch = $is_beq ? ($src1_value == $src2_value):
                         $is_bne ? ($src1_value != $src2_value):
                         $is_blt ? (($src1_value < $src2_value)^($src1_value[31] != $src2_value[31])):
                         $is_bge ? (($src1_value >= $src2_value)^($src1_value[31] != $src2_value[31])):
                         $is_bltu ? ($src1_value < $src2_value):
                         $is_bgeu ? ($src1_value >= $src2_value):
                                    1'b0;
          
          
         // Condition for Invalid Instruction                          
         $valid_taken_branch = $valid && $taken_branch;
         
         
       
         
         `BOGUS_USE($taken_branch)
        
         
         //Testbench
         *passed = |cpu/xreg[10]>>5$value == (1+2+3+4+5+6+7+8+9) ;
      // YOUR CODE HERE
      // ...

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      m4+dmem(@4)    // Args: (read/write stage)

   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule
```

![Screenshot 2024-08-21 230054](https://github.com/user-attachments/assets/a5dce635-e05e-42e1-a3bb-9624df7d953c)



![Screenshot 2024-08-21 214032](https://github.com/user-attachments/assets/309e17fd-88bc-4510-ba33-cdb0a184a06c)



![Screenshot 2024-08-21 214335](https://github.com/user-attachments/assets/95d115f9-7a2b-47f9-ab85-78fb6b14612a)


![Screenshot 2024-08-26 234950](https://github.com/user-attachments/assets/b30d36f1-1632-42e8-bf75-393dee85b245)


![Screenshot 2024-08-26 235414](https://github.com/user-attachments/assets/5f523211-dbe3-4f2b-af84-576b3bc39c9e)






# LAB 6

## Conversion from TLV into Verilog using Sandpiper-SaaS compiler.Following the conversion, pre-synthesis simulations will be conducted using the GTKWave simulator to verify the design.

The RISC-V processor was initially designed and created using the TL-Verilog language within the Makerchip IDE. For FPGA implementation, this design needed to be compiled and transformed into Verilog, a process accomplished using the SandPiper-SaaS compiler.

To prepare the design for FPGA synthesis and simulation, several adjustments were made to the TL-Verilog code:

Top Module Integration: The top module from Shivani Shah's GitHub repository was integrated into the TL-Verilog code to ensure compatibility and completeness of the design.

Case Inequality Corrections: Any inequalities within the case statements were corrected to avoid potential synthesis issues.

Input Cleanup: Instances of 'x' in the input signals were removed. Full, valid input values were provided to avoid errors during simulation and to ensure accurate operation.

Memory Line Adjustment: The CPU visualization (cpuviz) memory line was commented out, as it was not required for the synthesis process and could potentially lead to simulation errors.

After making these adjustments, a pre-synthesis simulation was carried out using the GTKWave simulator to verify the design's functionality before proceeding to the synthesis stage.

## Step by step procedure

#### 1. Install Required Packages: Begin by installing the necessary packages using pip:

```
sudo apt install make python python3 python3-pip git iverilog gtkwave
cd ~
sudo apt-get install python3-venv
python3 -m venv .venv
source ~/.venv/bin/activate
pip3 install pyyaml click sandpiper-saas
```
#### 2. Clone the github repo: clone this repo containing VSDBabySoC design files and testbench. Move into the VSDBabySoc directory

```
git clone https://github.com/manili/VSDBabySoC.git
cd /home/vsduser/VSDBabySoC/
```
#### 3. Replace the rvmyth.tlv file in the VSDBabySoC Directory: replace in src/module with the rvmth.tlv.

#### 4. Converting .tlv to .v using the SandPiper-SaaS Compiler:
    The RISC-V processor code was initially written in TL-Verilog (.tlv), a high-level hardware description language. To 
    translate the TL-Verilog definition of rvmyth into a low-level Verilog (.v) definition, we use the SandPiper-SaaS 
    compiler.
```
    sandpiper-saas -i ./src/module/*.tlv -o rvmyth.v --bestsv --noline -p verilog --outdir ./src/module/
```

#### 5. Compiling and Simulating the RISC-V Design

Before executing the following command, ensure you first create a directory named output. This directory will be used to store the pre-synthesis files generated during the compilation and simulation process.

```
mkdir output
iverilog -o output/pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module
```
#### 6. The result of the simulation (i.e. pre_synth_sim.vcd) will be stored in the output/pre_synth_sim directory.

```
cd output
./pre_synth_sim.out
```

#### 7. To open the .vcd simulation file through GTKWave simulation tool.

```
gtkwave pre_synth_sim.vcd
```
![WhatsApp Image 2024-08-27 at 00 14 43_6fa636d5](https://github.com/user-attachments/assets/8c5c64b3-31df-47ef-b829-5983069b2e53)


![WhatsApp Image 2024-08-27 at 00 14 43_5bb93262](https://github.com/user-attachments/assets/e883c238-1322-4582-86b3-7a3247a9314c)


![WhatsApp Image 2024-08-27 at 00 14 42_0babff5d](https://github.com/user-attachments/assets/0a2f457a-5136-4450-a098-5aa459490d4c)


![Screenshot 2024-08-21 214335](https://github.com/user-attachments/assets/95d115f9-7a2b-47f9-ab85-78fb6b14612a)


![Screenshot 2024-08-26 234950](https://github.com/user-attachments/assets/b30d36f1-1632-42e8-bf75-393dee85b245)


![Screenshot 2024-08-26 235414](https://github.com/user-attachments/assets/5f523211-dbe3-4f2b-af84-576b3bc39c9e)



# LAB 9
## TASK 1
### Installing iverilog, gtkwave, yosys, OpenSTA  in our personal machines.<br/>

 The following are the steps to install the tools which is used for simulation.<br/>
 
  * Iverilog<br/>
  Steps to install iverilog <br/>
  ```
    sudo apt-get update
    sudo apt-get install iverilog
  ```

![Screenshot from 2024-09-02 20-37-01](https://github.com/user-attachments/assets/d872e03c-c598-4cfe-8df6-eaf9ee358d43)


* Gtkwave<br/>
Steps to install gtkwave<br/>
```
sudo apt-get update
sudo apt install gtkwave
```
![Screenshot from 2024-09-02 20-39-01](https://github.com/user-attachments/assets/e645134f-ed18-4ca2-9463-6ddb910f7341)

![Screenshot from 2024-09-02 20-39-39](https://github.com/user-attachments/assets/46cc67c5-b6d9-4b6b-bd54-685fe58d7369)


* Yosys<br/>
Steps to install yosys<br/>
```



sudo apt-get update
 git clone https://github.com/YosysHQ/yosys.git
 cd yosys
 sudo apt install make (If make is not installed please install it) 
 sudo apt-get install build-essential clang bison flex \
    libreadline-dev gawk tcl-dev libffi-dev git \
    graphviz xdot pkg-config python3 libboost-system-dev \
    libboost-python-dev libboost-filesystem-dev zlib1g-dev
 make config-gcc
 make 
 sudo make install
```

![Screenshot from 2024-09-02 20-40-12](https://github.com/user-attachments/assets/f96f4e84-ed45-4769-9a5f-3c93f155c848)


* OpenSTA <br/>
Steps to install opensta<br/>
```
git clone https://github.com/parallaxsw/OpenSTA.git
cd OpenSTA
mkdir build
cd build
sudo apt-get install cmake clang gcctcl swig bison flex
cmake ..
make
```
![Screenshot from 2024-09-02 21-45-20](https://github.com/user-attachments/assets/7382ba7a-51be-4aab-8fb1-7c40e25f1b90)


## TASK 2
#### Downloading the files from https://github.com/Subhasis-Sahu/BabySoC_Simulation/ link and editing the vsdbabysoc top level so that it links to my rvmyth code and produce the output for that.

Converting a digital output from a CPU into an analog signal using a DAC (Digital-to-Analog Converter) and PLL (Phase-Locked Loop)

**1. Clone the repository**
```
 $ cd
 $ git clone https://github.com/Subhasis-Sahu/BabySoC_Simulation
```

```
$ iverilog -o ./pre_synth_sim.out -DPRE_SYNTH_SIM src/module/testbench.v -I src/include -I src/module/
$ ./pre_synth_sim.out
$ gtkwave pre_synth_sim.vcd
```

![Screenshot from 2024-09-02 23-58-40](https://github.com/user-attachments/assets/65a65650-c9f3-4088-b21b-a8699d967d42)




#### PLL input and DAC Output

  ![Screenshot from 2024-09-03 00-07-57](https://github.com/user-attachments/assets/2be25f89-bbbb-4cef-90d1-f3261ee1d535)

![Screenshot from 2024-09-02 23-52-47](https://github.com/user-attachments/assets/2cddbf09-8965-482d-9e6c-4cdd7f22245c)

![Screenshot from 2024-09-03 16-15-35](https://github.com/user-attachments/assets/c2808d21-f0a5-4471-98e4-98b2d0ecd476)


# LAB 10

## RTL DESIGN AND SYNTHESIS USING SKY180 TECHNOLOGY

### DAY 1 : Below are the snapshots of the tasks done in the day 1


![Screenshot from 2024-10-21 09-45-31](https://github.com/user-attachments/assets/8d3a4f2c-8f3a-4d05-b9da-b448f9408450)
![Screenshot from 2024-10-21 09-49-31](https://github.com/user-attachments/assets/691b4df3-ca98-4550-895c-6e20e3c420d3)
![Screenshot from 2024-10-21 09-54-29](https://github.com/user-attachments/assets/3a6a6fc8-d8f2-435a-b593-ed12c183dd6c)
![Screenshot from 2024-10-21 09-54-42](https://github.com/user-attachments/assets/3dcae30c-af95-4802-bf32-895118132c9e)
![Screenshot from 2024-10-21 09-58-11](https://github.com/user-attachments/assets/239643f6-e173-4f2c-b387-6cae7d9bbbf8)
![Screenshot from 2024-10-21 09-58-27](https://github.com/user-attachments/assets/48e13428-0e8b-4280-a06e-79ce1dfca2ef)
![Screenshot from 2024-10-21 10-10-25](https://github.com/user-attachments/assets/bddbd651-2f21-41ba-831b-013cbd755c40)
![Screenshot from 2024-10-21 10-13-36](https://github.com/user-attachments/assets/8f3d4290-6123-4dd1-a633-8fea2967e4fb)
![Screenshot from 2024-10-21 10-15-32](https://github.com/user-attachments/assets/6a28ba21-0740-48e8-a130-4fc79b175ec5)
![Screenshot from 2024-10-21 10-17-46](https://github.com/user-attachments/assets/0a57887e-97b5-4f4b-b31b-69103e01695b)
![Screenshot from 2024-10-21 10-20-37](https://github.com/user-attachments/assets/d1a8373b-6a35-473b-9eb1-fbdcf0bf6f7f)


### DAY 2 : Below are the snapshots of the tasks done in the day 2

![Screenshot from 2024-10-21 10-49-13](https://github.com/user-attachments/assets/39272ed6-8963-4b28-8760-794652aaf2ab)
![Screenshot from 2024-10-21 10-49-22](https://github.com/user-attachments/assets/d541512e-8b5a-419a-b257-d2b40062a731)
![Screenshot from 2024-10-21 10-49-31](https://github.com/user-attachments/assets/c4b0902d-949e-4d48-8635-e8a2c7725125)
![Screenshot from 2024-10-21 10-52-41](https://github.com/user-attachments/assets/54065fd0-a95b-4b6b-aee5-20aa3887551c)
![Screenshot from 2024-10-21 10-55-23](https://github.com/user-attachments/assets/2ffcd462-860a-4170-a734-319ea7e2cb0b)
![Screenshot from 2024-10-21 10-56-31](https://github.com/user-attachments/assets/2fdd07ed-ca54-4ab3-9ca3-64499854a02a)
![Screenshot from 2024-10-21 10-56-34](https://github.com/user-attachments/assets/b1da3eb4-4ea6-409e-a714-d271a702a80a)
![Screenshot from 2024-10-21 10-59-11](https://github.com/user-attachments/assets/9bb17bcd-f715-4e43-9eca-b9da15993e48)
![Screenshot from 2024-10-21 10-59-38](https://github.com/user-attachments/assets/30a4a3b0-d292-4ad3-b7a0-9e7193a72536)
![Screenshot from 2024-10-21 11-01-48](https://github.com/user-attachments/assets/31b4414a-8a62-4888-82ec-cebaa3f928bc)
![Screenshot from 2024-10-21 11-01-51](https://github.com/user-attachments/assets/e5c95821-4ef3-4d0e-ba3f-10511942f09f)
![Screenshot from 2024-10-21 11-09-59](https://github.com/user-attachments/assets/ca5e87ae-b87f-4f1a-9764-e90ce44179b5)
![Screenshot from 2024-10-21 11-10-02](https://github.com/user-attachments/assets/c96eba44-9e74-452a-81b8-fefb5769d962)
![Screenshot from 2024-10-21 11-11-58](https://github.com/user-attachments/assets/b6c8fe48-9a0a-4984-952e-2a61cec4ea52)
![Screenshot from 2024-10-21 11-14-12](https://github.com/user-attachments/assets/de04420b-7517-4c08-9817-bf034af187c4)
![Screenshot from 2024-10-21 11-17-27](https://github.com/user-attachments/assets/e95cfb2c-0040-408d-9682-da90b0c0d95a)
![Screenshot from 2024-10-21 11-17-39](https://github.com/user-attachments/assets/40cdf035-8ed0-4489-b59c-f0a6eb85bf01)
![Screenshot from 2024-10-21 11-18-23](https://github.com/user-attachments/assets/6cae2f6a-b472-4d9d-ab55-8547e5add866)






